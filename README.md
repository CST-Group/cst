## Welcome to the CST Toolkit pages.
The [CST Toolkit](http://cst.fee.unicamp.br) is a Java-based toolkit to allow the construction of Cognitive Architectures. It is being developed at the [University of Campinas](http://www.dca.fee.unicamp.br) by a group of researchers in the field of Cognitive Architectures leaded by Prof. [Ricardo Gudwin](http://faculty.dca.fee.unicamp.br/gudwin). 

## Cognitive Architectures
Cognitive Architectures are general-purpose control systems' architectures inspired by scientific theories developed to explain cognition in animals and men. Cognitive Architectures have been employed in many different kinds of applications, since the control of robots to decision-making processes in intelligent agents. Usually, a cognitive architecture is decomposed based on its cognitive capabilities, like perception, attention, memory, reasoning, learning, behavior generation, etc. 
Cognitive Architectures are, at the same time, theoretical modelings for how many different cognitive processes interact to each other in order to sense, reason and act, and also a software framework which can be reused through different applications. The most popular cognitive architectures usually have their code available at the Internet (with different kinds of licenses), such that different researchers are able to download this code and make experimentations with these architectures. 

## Origins of the CST Toolkit
The CST toolkit has been used successfully in a number of MS and PhD thesis in our group, either for building a cognitive architecture to be used in a particular experiment or also to foster further improvements in the own CST code due to the applications requirements.

## Basic Notions
Figure 1 illustrates the core of the CST toolkit. The basic notion, which is used in a widespread way within the cognitive architecture is the notion of a codelet. Codelets are small pieces of non-blocking code, each of them executing a well defined and simple task. The idea of a codelet is of a piece of code which ideally shall be executed continuously and cyclically, time after time, being responsible for the behavior of a system's independent component running in parallel. The notion of codelet was introduced originally by Hofstadter and Mitchell (1994) and further enhanced by Franklin (1998). The CST architecture is codelet oriented, since all main cognitive functions are implemented as codelets. This means that from a conceptual point of view, any CST-implemented system is a fully parallel asynchronous multi-agent system, where each agent is modeled by a codelet. CST's codelets are implemented much in the same manner as in the [LIDA cognitive architecture](http://ccrg.cs.memphis.edu/framework.html) and largely correspond to the special-purpose processes described in Baar's Global Workspace Theory (Baars & Franklin 2007). Nevertheless, for the system to work, a kind of coordination must exist among codelets, forming coalitions which by means of a coordinated interaction, are able to implement the cognitive functions ascribed to the architecture. This coordination constraint imposes special restrictions while implementing codelets in a serial computer. In a real parallel system, a codelet would simply be called in a loop, being responsible to implement the behavior of a parallel component. In a serial system like a computer, the overall system might have to share the CPU with its many components. In time-sharing systems, the concepts of process and thread could be used to implement systems with requirements like this. Nevertheless, in a cognitive system, there might be some subtleties, which might make an implementation with real threads an unsuitable one. Using real threads, in a context of a large number of threads, situations where some thread is called many times while other threads are called none or just a few times might appear, due to optimization constraints. In a codelet-based cognitive architecture, there might be a very large number of codelets, each of them responsible for the implementation of a small part of a coordinated system of components. Some of these codelets might be critical for the system performance, in terms of time restrictions. Other codelets might have more relaxed conditions. In a serial system, where it might be impossible to run all the codelets in parallel, a scheduling mechanism should be employed to guarantee that more important codelets are called more frequently, taking the preference from not-so-critical codelets. Another constraint is that usually, there might be a predefined order in which the codelets should be called, generated by the coordination constraint (e.g. perception codelets should be called before reasoning codelets, because reasoning codelets need the outputs of perception codelets as its inputs). 

![CST Core](http://faculty.dca.fee.unicamp.br/gudwin/sites/faculty.dca.fee.unicamp.br.gudwin/files/cst/CogSys-Core.png)

Figure 1 - The CST Core

A codelet has two main inputs (which are characterized as In and B in the figure), a local input (In) and a global input (B). The local input is used for the codelet to get information from memory objects, which are available at the Raw Memory. The global input is used for the codelet to get information from the global workspace mechanism (Baars & Franklin 2007). The information coming from the global workspace is variable at each instant of time, and usually is related to a summary, an executive filter which select the most relevant piece of information available in memory at each timestep. The two outputs of a codelet are a standard output, which is used to change or create new information in the Raw Memory, and the value level, which indicates the relevance of the information provided at the output, and is used by the Global Workspace mechanism in order to select information to be destined to the global workspace. 
Using this Core, the CST toolkit provides different kinds of codelets to perform most of the cognitive functions available at a cognitive architecture, as indicated in figure 2. Also, memory objects are scattered among many different kinds of memories. The Raw Memory is so split into many different memory systems, which are used to store and access different kinds of knowledge.  Using the available codelets, different cognitive architectures, using different strategies for perception, attention, learning, planning and behavior generation can be composed in order to perform the role necessary to address a specific control problem. These codelets are constructed according to different techniques in intelligent systems, like neural networks, fuzzy systems, evolutionary computation, rule-based systems, Bayesian networks, etc., which are integrated into a whole control and monitoring system. 
The definition and choice of a particular cognitive architecture is constructed using a composition of different kinds of codelets, according to the control problem under analysis. Depending on the problem to be addressed, different strategies might be necessary or useful, depending on the problem constraints. 

![CST Overall Architecture](http://faculty.dca.fee.unicamp.br/gudwin/sites/faculty.dca.fee.unicamp.br.gudwin/files/cst/CogSys-Codelets.png)

Figure 2 - The CST Overall Architecture: Codelets

## Requirements

CST requires at minimum Java 8.

### Authors and Contributors
The main contributors of this project are: 
* [Ricardo Ribeiro Gudwin](https://github.com/rgudwin)
* [Klaus Raizer](https://github.com/KRaizer)
* [André Luís Ogando Paraense](https://github.com/andre-paraense)
* [Suelen Mapa de Paula](https://github.com/suelenmapa)
* Vera Aparecida de Figueiredo
* [Elisa Calhau de Castro](https://github.com/ecalhau)
* [Eduardo de Moraes Fróes](https://github.com/eduardofroes)
* [Wandemberg Santana Pharaoh Gibaut](https://github.com/wandergibaut)

License
--------

    Copyright 2016 CST-Group

    Licensed under the GNU LESSER GENERAL PUBLIC LICENSE, Version 3 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.gnu.org/licenses/lgpl-3.0.html

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    
    
